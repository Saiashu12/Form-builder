{"ast":null,"code":"export const validateField=(value,rules)=>{const errors=[];for(const rule of rules){switch(rule.type){case'required':if(!value||typeof value==='string'&&value.trim()===''){errors.push(rule.message);}break;case'minLength':if(value&&typeof value==='string'&&value.length<rule.value){errors.push(rule.message);}break;case'maxLength':if(value&&typeof value==='string'&&value.length>rule.value){errors.push(rule.message);}break;case'email':if(value&&typeof value==='string'){const emailRegex=/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;if(!emailRegex.test(value)){errors.push(rule.message);}}break;case'password':if(value&&typeof value==='string'){if(value.length<8||!/\\d/.test(value)){errors.push(rule.message);}}break;}}return errors;};export const calculateDerivedValue=(formula,formData)=>{try{// Simple formula evaluation - in production, you'd want a more robust solution\n// For age calculation from date of birth\nif(formula.includes('new Date().getFullYear() - new Date(')&&formula.includes(').getFullYear()')){var _formula$match;const fieldName=(_formula$match=formula.match(/new Date\\((\\w+)\\)/))===null||_formula$match===void 0?void 0:_formula$match[1];if(fieldName&&formData[fieldName]){const birthDate=new Date(formData[fieldName]);const today=new Date();let age=today.getFullYear()-birthDate.getFullYear();const monthDiff=today.getMonth()-birthDate.getMonth();if(monthDiff<0||monthDiff===0&&today.getDate()<birthDate.getDate()){age--;}return age;}}// Simple arithmetic operations\nlet evaluatedFormula=formula;Object.keys(formData).forEach(key=>{const value=formData[key];if(typeof value==='number'){evaluatedFormula=evaluatedFormula.replace(new RegExp(key,'g'),value.toString());}});// Basic arithmetic evaluation (be careful with eval in production)\nif(/^[\\d\\s+\\-*/().]+$/.test(evaluatedFormula)){return eval(evaluatedFormula);}return'';}catch(error){console.error('Error calculating derived value:',error);return'';}};","map":{"version":3,"names":["validateField","value","rules","errors","rule","type","trim","push","message","length","emailRegex","test","calculateDerivedValue","formula","formData","includes","_formula$match","fieldName","match","birthDate","Date","today","age","getFullYear","monthDiff","getMonth","getDate","evaluatedFormula","Object","keys","forEach","key","replace","RegExp","toString","eval","error","console"],"sources":["C:/Dynamic Form Builder Application/src/utils/validation.ts"],"sourcesContent":["import { ValidationRule } from '../types/form.ts';\n\nexport const validateField = (value: any, rules: ValidationRule[]): string[] => {\n  const errors: string[] = [];\n\n  for (const rule of rules) {\n    switch (rule.type) {\n      case 'required':\n        if (!value || (typeof value === 'string' && value.trim() === '')) {\n          errors.push(rule.message);\n        }\n        break;\n      \n      case 'minLength':\n        if (value && typeof value === 'string' && value.length < (rule.value as number)) {\n          errors.push(rule.message);\n        }\n        break;\n      \n      case 'maxLength':\n        if (value && typeof value === 'string' && value.length > (rule.value as number)) {\n          errors.push(rule.message);\n        }\n        break;\n      \n      case 'email':\n        if (value && typeof value === 'string') {\n          const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n          if (!emailRegex.test(value)) {\n            errors.push(rule.message);\n          }\n        }\n        break;\n      \n      case 'password':\n        if (value && typeof value === 'string') {\n          if (value.length < 8 || !/\\d/.test(value)) {\n            errors.push(rule.message);\n          }\n        }\n        break;\n    }\n  }\n\n  return errors;\n};\n\nexport const calculateDerivedValue = (formula: string, formData: Record<string, any>): any => {\n  try {\n    // Simple formula evaluation - in production, you'd want a more robust solution\n    // For age calculation from date of birth\n    if (formula.includes('new Date().getFullYear() - new Date(') && formula.includes(').getFullYear()')) {\n      const fieldName = formula.match(/new Date\\((\\w+)\\)/)?.[1];\n      if (fieldName && formData[fieldName]) {\n        const birthDate = new Date(formData[fieldName]);\n        const today = new Date();\n        let age = today.getFullYear() - birthDate.getFullYear();\n        const monthDiff = today.getMonth() - birthDate.getMonth();\n        if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {\n          age--;\n        }\n        return age;\n      }\n    }\n    \n    // Simple arithmetic operations\n    let evaluatedFormula = formula;\n    Object.keys(formData).forEach(key => {\n      const value = formData[key];\n      if (typeof value === 'number') {\n        evaluatedFormula = evaluatedFormula.replace(new RegExp(key, 'g'), value.toString());\n      }\n    });\n    \n    // Basic arithmetic evaluation (be careful with eval in production)\n    if (/^[\\d\\s+\\-*/().]+$/.test(evaluatedFormula)) {\n      return eval(evaluatedFormula);\n    }\n    \n    return '';\n  } catch (error) {\n    console.error('Error calculating derived value:', error);\n    return '';\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}